// vim: ft=c
#include <ttest.h>

#include "vmm.c"

void *data;
uintptr_t *p4, *p3, *p2, *p1;

#define ADDR1234 ((1UL<<39) + (2UL<<30) + (3UL<<21) + (4UL<<12))
#define BUILD_PT(o4, o3, o2) \
  p4[(o4)] = (uintptr_t)p3; p4[(o4)] |= PAGE_PRESENT; \
  p3[(o3)] = (uintptr_t)p2; p3[(o3)] |= PAGE_PRESENT; \
  p2[(o2)] = (uintptr_t)p1; p2[(o2)] |= PAGE_PRESENT;

BEFORE()
{
  data = calloc(PAGE_SIZE, 5);
  p4 = (void *)(((uintptr_t)data + PAGE_SIZE) & ~(PAGE_SIZE-1));
  p3 = &p4[512];
  p2 = &p4[1024];
  p1 = &p4[1536];
}
AFTER()
{
  free(data);
}

TEST(get_page_returns_correct_address)
{
  BUILD_PT(0,0,0);
  p1[0] = 0x1234567890ABC000 | PAGE_PRESENT;

  uintptr_t ret = vmm_get_page(p4, 0);

  ASSERT_EQ_PTR(ret, 0x1234567890ABC000 | PAGE_PRESENT);
}
TEST(get_page_ignores_flags)
{
  BUILD_PT(0,0,0);
  p1[0] = 0x1234567890ABC000 | PAGE_PRESENT;

  uintptr_t ret = vmm_get_page(p4, 0);

  ASSERT_EQ_PTR(ret, 0x1234567890ABC000 | PAGE_PRESENT);
}
TEST(get_page_works_for_different_address)
{
  BUILD_PT(1,2,3)
  p1[4] = 0x34567890ABCDE000 | PAGE_PRESENT;

  uintptr_t ret = vmm_get_page(p4, ADDR1234);

  ASSERT_EQ_PTR(ret, 0x34567890ABCDE000 | PAGE_PRESENT);
}
TEST(get_page_fails_if_PTE_not_present)
{
  BUILD_PT(0,0,0);
  p2[0] = (uintptr_t)p1;
  p1[0] = 0x1234567890ABC000 | PAGE_PRESENT;

  uintptr_t ret = vmm_get_page(p4, 0);

  ASSERT_EQ_PTR(ret, -1);
}

TEST(set_page_sets_page)
{
  BUILD_PT(0,0,0);

  vmm_set_page(p4, 0, 0x1234567890ABC000, PAGE_PRESENT);

  ASSERT_EQ_PTR(p1[0], 0x1234567890ABC000 | PAGE_PRESENT);
}
TEST(set_page_returns_success_if_working)
{
  BUILD_PT(0,0,0);

  int retval = vmm_set_page(p4, 0, 0x1234567890ABC000, PAGE_PRESENT);

  ASSERT_EQ_INT(retval, 0);
}
TEST(set_page_fails_if_PT_missing)
{
  BUILD_PT(0,0,0);
  p3[0] = (uintptr_t)p2;

  int retval = vmm_set_page(p4, 0, 0x1234567890ABC000, PAGE_PRESENT);

  ASSERT_NEQ_INT(retval, 0);
}

uintptr_t pmm_alloc()
{
  uintptr_t *pages[] = {p3, p2, p1};
  static int counter=0;
  if(counter >= 3) return 0;
  return (uintptr_t)pages[counter++];
}

TEST(touch_page_adds_P3)
{
  touch_page(p4, ADDR1234, 0);

  ASSERT_EQ_PTR(p4[1], (uintptr_t)p3 | PAGE_PRESENT);
}
TEST(touch_page_adds_P2)
{
  touch_page(p4, ADDR1234, 0);

  ASSERT_EQ_PTR(p3[2], (uintptr_t)p2 | PAGE_PRESENT);
}
TEST(touch_page_adds_P1)
{
  touch_page(p4, ADDR1234, 0);

  ASSERT_EQ_PTR(p2[3], (uintptr_t)p1 | PAGE_PRESENT);
}
TEST(touch_page_sets_flags)
{
  touch_page(p4, 0, 0x123);

  ASSERT_EQ_PTR(p2[0], (uintptr_t)p1 | 0x123 | PAGE_PRESENT);
}
TEST(touch_page_fails_if_out_of_pages)
{
  pmm_alloc();
  int retval = touch_page(p4, 0, 0);
  ASSERT_NEQ_INT(retval, 0);
}

TEST(free_page_unsets_page)
{
  BUILD_PT(1,2,3);
  p1[4] = PAGE_PRESENT;

  free_page(p4, ADDR1234, 0);

  ASSERT_EQ_PTR(p1[4], 0);
}
TEST(free_page_unsets_P2_entry_if_P1_is_empty)
{
  BUILD_PT(1,2,3);
  p1[4] = PAGE_PRESENT;

  free_page(p4, ADDR1234, 1);

  ASSERT_EQ_PTR(p2[3], 0);
}
TEST(free_page_does_not_unset_P2_entry_if_not_asked_to)
{
  BUILD_PT(1,2,3);
  p1[4] = PAGE_PRESENT;

  free_page(p4, ADDR1234, 0);

  ASSERT_NEQ_PTR(p2[3], 0);
}
